// -------------------------------------------------------------
// 
// File Name: C:\Users\huber\Downloads\hdlsrc\HDLAWGNGenerator\HDLAWGNGenerator\RangeReduction.v
// Created: 2021-06-06 18:19:42
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: RangeReduction
// Source Path: HDLAWGNGenerator/AWGNGenerator/GaussianNoiseWithUnitVar/SqrtImplementation/SqrtEval/RangeReduction
// Hierarchy Level: 4
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module RangeReduction
          (clk,
           reset,
           enb,
           u,
           x_f,
           pass,
           exp_f);


  input   clk;
  input   reset;
  input   enb;
  input   [30:0] u;  // ufix31_En24
  output  [30:0] x_f;  // ufix31_En24
  output  signed [8:0] pass;  // sfix9
  output  signed [7:0] exp_f;  // int8


  wire [7:0] Constant_out1;  // uint8
  reg [7:0] Delay3_out1;  // uint8
  wire [7:0] exp_f_1;  // uint8
  reg [7:0] Delay4_out1;  // uint8
  wire signed [8:0] Add_sub_temp;  // sfix9
  wire signed [8:0] Add_1;  // sfix9
  wire signed [8:0] Add_2;  // sfix9
  wire signed [7:0] Add_out1;  // int8
  wire signed [7:0] Shift_Arithmetic3_out1;  // int8
  wire signed [7:0] Shift_Arithmetic4_out1;  // int8
  wire signed [8:0] Subtract_1;  // sfix9
  wire signed [8:0] Subtract_2;  // sfix9
  wire signed [8:0] Subtract_out1;  // sfix9
  wire shift_arithmetic_shift_direction;
  reg [30:0] Delay2_out1;  // ufix31_En24
  wire signed [8:0] shift_arithmetic_abs_y;  // sfix9
  wire signed [8:0] shift_arithmetic_abs_1;  // sfix9
  wire [8:0] shift_arithmetic_shift_value;  // ufix9
  wire [15:0] shift_right_cast;  // uint16
  wire [30:0] shift_arithmetic_right;  // ufix31_En24
  wire [15:0] shift_left_cast;  // uint16
  wire [30:0] shift_arithmetic_left;  // ufix31_En24
  wire [30:0] x_f1;  // ufix31_En24
  wire [30:0] Shift_Arithmetic1_out1;  // ufix31_En24
  wire [30:0] Switch_out1;  // ufix31_En24

  // Range of x_f=[1,4)


  assign Constant_out1 = 8'b00000101;



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Constant_out1;
        end
      end
    end



  MATLAB_Function u_MATLAB_Function (.x(u),  // ufix31_En24
                                     .exp_f(exp_f_1)  // uint8
                                     );

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= exp_f_1;
        end
      end
    end



  assign Add_1 = {1'b0, Delay3_out1};
  assign Add_2 = {1'b0, Delay4_out1};
  assign Add_sub_temp = Add_1 - Add_2;
  assign Add_out1 = Add_sub_temp[7:0];



  assign Shift_Arithmetic3_out1 = Add_out1 >>> 8'd1;



  assign Shift_Arithmetic4_out1 = Shift_Arithmetic3_out1 <<< 8'd1;



  assign Subtract_1 = {Add_out1[7], Add_out1};
  assign Subtract_2 = {Shift_Arithmetic4_out1[7], Shift_Arithmetic4_out1};
  assign Subtract_out1 = Subtract_1 - Subtract_2;



  assign shift_arithmetic_shift_direction = Add_out1 < 8'sb00000000;



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 31'b0000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= u;
        end
      end
    end



  assign shift_arithmetic_abs_1 = {Add_out1[7], Add_out1};
  assign shift_arithmetic_abs_y = (Add_out1 < 8'sb00000000 ?  - (shift_arithmetic_abs_1) :
              {Add_out1[7], Add_out1});
  assign shift_arithmetic_shift_value = shift_arithmetic_abs_y;



  assign shift_right_cast = {7'b0, shift_arithmetic_shift_value};
  assign shift_arithmetic_right = Delay2_out1 >>> shift_right_cast;



  assign shift_left_cast = {7'b0, shift_arithmetic_shift_value};
  assign shift_arithmetic_left = Delay2_out1 <<< shift_left_cast;



  assign x_f1 = (shift_arithmetic_shift_direction == 1'b0 ? shift_arithmetic_right :
              shift_arithmetic_left);



  assign Shift_Arithmetic1_out1 = x_f1 >>> 8'd1;



  assign Switch_out1 = (Subtract_out1 == 9'sb000000000 ? x_f1 :
              Shift_Arithmetic1_out1);



  assign x_f = Switch_out1;

  assign pass = Subtract_out1;

  assign exp_f = Add_out1;

endmodule  // RangeReduction

