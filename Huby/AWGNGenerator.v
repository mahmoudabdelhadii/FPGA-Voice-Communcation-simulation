// -------------------------------------------------------------
// 
// File Name: C:\Users\huber\Downloads\hdlsrc\HDLAWGNGenerator\HDLAWGNGenerator\AWGNGenerator.v
// Created: 2021-06-06 18:19:43
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1e-06
// Target subsystem base rate: 1e-06
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1e-06
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// awgn_re                       ce_out        1e-06
// awgn_im                       ce_out        1e-06
// valid                         ce_out        1e-06
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: AWGNGenerator
// Source Path: HDLAWGNGenerator/AWGNGenerator
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module AWGNGenerator
          (clk,
           reset,
           clk_enable,
           snrdB,
           ce_out,
           awgn_re,
           awgn_im,
           valid);


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [15:0] snrdB;  // sfix16_En9
  output  ce_out;
  output  signed [37:0] awgn_re;  // sfix38_En29
  output  signed [37:0] awgn_im;  // sfix38_En29
  output  valid;


  wire enb;
  wire [21:0] alphadBtoLinearConverter_out1;  // ufix22_En18
  reg [21:0] Delay1_reg [0:9];  // ufix22 [10]
  wire [21:0] Delay1_reg_next [0:9];  // ufix22_En18 [10]
  wire [21:0] Delay1_out1;  // ufix22_En18
  wire signed [15:0] x0_16_11;  // sfix16_En11
  wire signed [15:0] x1_16_11;  // sfix16_En11
  wire signed [37:0] GaussianNoiseWithReqVar_out1_re;  // sfix38_En29
  wire signed [37:0] GaussianNoiseWithReqVar_out1_im;  // sfix38_En29
  wire GaussianNoiseWithReqVar_out2;


  alphadBtoLinearConverter u_dBtoLinearConverter (.clk(clk),
                                                  .reset(reset),
                                                  .enb(clk_enable),
                                                  .snrdB(snrdB),  // sfix16_En9
                                                  .noiseVar(alphadBtoLinearConverter_out1)  // ufix22_En18
                                                  );

  assign enb = clk_enable;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg[0] <= 22'b0000000000000000000000;
        Delay1_reg[1] <= 22'b0000000000000000000000;
        Delay1_reg[2] <= 22'b0000000000000000000000;
        Delay1_reg[3] <= 22'b0000000000000000000000;
        Delay1_reg[4] <= 22'b0000000000000000000000;
        Delay1_reg[5] <= 22'b0000000000000000000000;
        Delay1_reg[6] <= 22'b0000000000000000000000;
        Delay1_reg[7] <= 22'b0000000000000000000000;
        Delay1_reg[8] <= 22'b0000000000000000000000;
        Delay1_reg[9] <= 22'b0000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= Delay1_reg_next[0];
          Delay1_reg[1] <= Delay1_reg_next[1];
          Delay1_reg[2] <= Delay1_reg_next[2];
          Delay1_reg[3] <= Delay1_reg_next[3];
          Delay1_reg[4] <= Delay1_reg_next[4];
          Delay1_reg[5] <= Delay1_reg_next[5];
          Delay1_reg[6] <= Delay1_reg_next[6];
          Delay1_reg[7] <= Delay1_reg_next[7];
          Delay1_reg[8] <= Delay1_reg_next[8];
          Delay1_reg[9] <= Delay1_reg_next[9];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[9];
  assign Delay1_reg_next[0] = alphadBtoLinearConverter_out1;
  assign Delay1_reg_next[1] = Delay1_reg[0];
  assign Delay1_reg_next[2] = Delay1_reg[1];
  assign Delay1_reg_next[3] = Delay1_reg[2];
  assign Delay1_reg_next[4] = Delay1_reg[3];
  assign Delay1_reg_next[5] = Delay1_reg[4];
  assign Delay1_reg_next[6] = Delay1_reg[5];
  assign Delay1_reg_next[7] = Delay1_reg[6];
  assign Delay1_reg_next[8] = Delay1_reg[7];
  assign Delay1_reg_next[9] = Delay1_reg[8];



  GaussianNoiseWithUnitVar u_GaussianNoiseWithUnitVar (.clk(clk),
                                                       .reset(reset),
                                                       .enb(clk_enable),
                                                       .x0(x0_16_11),  // sfix16_En11
                                                       .x1(x1_16_11)  // sfix16_En11
                                                       );

  GaussianNoiseWithReqVar u_GaussianNoiseWithReqVar (.clk(clk),
                                                     .reset(reset),
                                                     .enb(clk_enable),
                                                     .noiseVar(Delay1_out1),  // ufix22_En18
                                                     .x0(x0_16_11),  // sfix16_En11
                                                     .x1(x1_16_11),  // sfix16_En11
                                                     .awgn_re(GaussianNoiseWithReqVar_out1_re),  // sfix38_En29
                                                     .awgn_im(GaussianNoiseWithReqVar_out1_im),  // sfix38_En29
                                                     .validOut(GaussianNoiseWithReqVar_out2)
                                                     );

  assign awgn_re = GaussianNoiseWithReqVar_out1_re;

  assign awgn_im = GaussianNoiseWithReqVar_out1_im;

  assign valid = GaussianNoiseWithReqVar_out2;

  assign ce_out = clk_enable;

endmodule  // AWGNGenerator

